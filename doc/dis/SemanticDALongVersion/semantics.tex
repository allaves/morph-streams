\section{Semantics of the Streaming Extensions}
\label{semanticsstreaming}

Now that the syntax of \sparqlstr and \stwoo have been presented, we define their semantics.

\subsection{SPARQL\subscript{Stream} Semantics}
\label{sparqlstrsemantics}

The \sparql extensions presented here are based on the formalisation of %\csparql \cite{Barbieri_2010}, which are in turn based on the work of 
P\'erez \etal \cite{Perez_09}.
An \rdf stream $S$ is defined as a sequence of pairs $(T,\tau)$ where $T$ is a triple  $\langle s,p,o \rangle$ and $\tau$ is a timestamp in the infinite set of timestamps $\Time$.
More formally, 
\begin{align*}
S =\;& \{( \langle s,p,o \rangle, \tau) \mid \langle s,p,o \rangle \in \\
     & ((I \cup B) \times I \times (I \cup B \cup L)  ), \tau \in \Time\},
\end{align*}
where $I$, $B$ and $L$ are sets of \iri \!\!s, blank nodes and literals. 
Each of these pairs can be called a \emph{tagged triple}.

We define a stream of windows as a sequence of pairs $(\omega, \tau)$ where $\omega$ is a set of triples, each of the form $\langle s, p, o \rangle$, and $\tau$ is a timestamp in the infinite set of timestamps $\Time$, and represents when the window was evaluated.
More formally, we define the triples that are contained in a time-based window evaluated at time $\tau \in \Time$, denoted $\omega^{\tau}$, as
\begin{align*}
  \omega^{\tau}_{t_{s},t_{e},\delta}(S)=\{ \langle s,p,o \rangle \mid (\langle s,p,o \rangle, \tau_i) \in S, t_{s} \leq \tau_i \leq t_{e}\}
\end{align*}
where $t_s$, $t_e$ define the start and end of the window time range respectively, and may be defined relative to the evaluation time $\tau$. 
%\fixme{I have changed the lower bound on the window to be inclusive. This is the normal interpretation in relational stream languages.}
Note that the rate at which windows get evaluated is controlled by the \textsf{\small{STEP}} defined in the query, which is denoted by $\delta$.% which in the following is captured by $\delta$ in the following expressions.

We define the three window-to-stream operators as
\begin{align*}
  \textsf{RStream}(
		{\scriptstyle (\omega^\tau, \tau)}) 
		=& \{(\langle s, p, o \rangle, \tau) \mid \\
	 	 & \langle s, p, o \rangle \in \omega^\tau\}\\
%
  \textsf{IStream}(
		{\scriptstyle (\omega^\tau, \tau), (\omega^{\tau-\delta}, \tau - \delta)}) 
		=& \{(\langle s, p, o \rangle, \tau) \mid \\
		& \langle s, p, o \rangle \in \omega^\tau, \langle s, p, o \rangle \notin \omega^{\tau-\delta}\}\\
%
  \textsf{DStream}(
		{\scriptstyle (\omega^\tau, \tau), (\omega^{\tau-\delta}, \tau - \delta)})
		=& \{(\langle s, p, o \rangle, \tau) \mid \\
		& \langle s, p, o \rangle \notin \omega^\tau, \langle s, p, o \rangle \in \omega^{\tau-\delta}\}
\end{align*}
where $\delta$ is the time interval between window evaluations.
Note that \textsf{RStream} does not depend on the previous window evaluation, whereas both \textsf{IStream} and \textsf{DStream} depend on the contents of the previous window.

We have provided a brief explanation of the semantics of \sparqlstr. 
This is particularly useful in the sense that users may know what to expect when they issue a query using these new operators. 
However, as the actual data source is not an \rdf stream but a sensor network or an event-based stream, \eg exposed as a \sneeql endpoint, we need to transform the \sparqlstr queries into \sneeql queries.
The next section describes the semantics of the transformation from \sparqlstr to \sneeql using the \stwoo mappings.


\subsection{\bigstwoo Semantics}
\label{mappingsemantics}

%We formalise the semantics of answering unions of conjunctive queries over an ontological schema, and accessing the underlying data sources through mappings. 
%We are particularly interested in answering unions of conjunctive queries (a subset of \sparqlstr) over an ontological schema, 
%\fixme{One of the ESWC reviews did not like our explanation of this limitation to conjunctive queries. We should provide some support for this claim.}
In this section we will present how we can use the \stwoo mapping definitions to transform a set of conjunctive queries over an ontological schema, into the streaming query language \sneeql that is used to access the sources. 
This work is based on extensions to the \odemapster processor \cite{Barrasa_04} and the
formalisation work of \citet{Calvanese_05} and \citet{Poggi_08}.

A conjunctive query $q$ over an ontology $\mathcal{O}$ can be expressed as:
\begin{align*}
q(\vec{x}) \leftarrow \varphi(\vec{x},\vec{y}) \\
%
\varphi(\vec{x},\vec{y}):\underset{i=1...k}{\bigwedge}P_i \mbox{, with } P_i &
\begin{cases} 
{\scriptstyle C_i(x), C_i\: \mbox{\scriptsize is an atomic class.} }\\ 
{\scriptstyle R_i(x,y),   R_i\: \mbox{\scriptsize is an atomic property.} }\\ 
{\scriptstyle x=y}
\end{cases} \\
& {\scriptstyle x,y\: \mbox{\scriptsize are variables in $\vec{x}, \vec{y}$ or constants.}}
\end{align*}
%
where $\vec{x}$ is a tuple of distinct distinguished variables, and $\vec{y}$ a tuple of non-distinguished existentially quantified variables. 
The answer to this query consists in the instantiation of the distinguished variables
\cite{Calvanese_05}. 
For instance consider:
\begin{align*}
q_1(x) \leftarrow & WindSpeedObservation(x)\wedge \\
						& isProducedBy(x,y)\wedge\\
						& WindSensor(y)
\end{align*}
%\fixme{Change example to fire use case to make consistent with the rest of the paper.}
It requires all instances $x$ that are wind speed measurements captured by wind sensors.
In this example $x$ is a distinguished variable and $y$ a non-distinguished one. 
The query has three atoms: $WindSpeedObservation(x)$, $isProducedBy(x,y)$, and $WindSensor(y)$.

Concerning the formal definition of the query answering, let $\mathcal{I}=(\Delta^\mathcal{I} ,\centerdot^\mathcal{I})$ be an interpretation, where $\Delta^\mathcal{I}$ is the interpretation domain and $\centerdot^\mathcal{I}$ the interpretation function that assigns an element of $\Delta^\mathcal{I}$ to each constant, a subset of $\Delta^\mathcal{I}$ to each class and a subset of $\Delta^\mathcal{I} \times \Delta^\mathcal{I}$ to each property of the ontology.
Given a query $q(\vec{x})\leftarrow \varphi(\vec{x},\vec{y})$ the answer to $q$ is the set $q^{\mathcal{I}}_{\vec{x}}$ of tuples $\vec{c} \in \Delta^\mathcal{I} \times \dots \times \Delta^\mathcal{I}$ that substituted to $\vec{x}$, make the formula $\exists\vec{y}.\varphi(\vec{x},\vec{y})$ true in $\mathcal{I}$ \cite{Calvanese_05,Poggi_08,Lubyte_09}.
Now we can introduce the definition of the mappings. 
Let $\mathcal{M}$ be a set of mapping assertions of the form:
\begin{equation*}
\Psi \leadsto \Phi
\end{equation*}
where $\Psi$ is a conjunctive query over the global ontology $\mathcal{O}$, formed by terms of the form $C(x), R(x,y), A(x,z)$, with $C$, $R$, and $A$ being classes, object properties and datatype properties respectively in $\mathcal{O}$; $x, y$ being object instance variables, and $z$ being a datatype variable. 
$\Phi$ is a set of expressions that can be translated to queries in the target continuous language (\eg \sneeql) over the sources.

A mapping assertion $C(f_C^{Id}(\vec{x})) \leadsto \Phi_{S_1,\ldots,S_n}(\vec{x})$ describes how to construct the concept $C$ from the source streams (or relations) $S_1,\ldots,S_n$. 
The function $f_C^{Id}$ creates an instance of the class $C$, given the tuple $\vec{x}$ of variables returned by the $\Phi$ expression. 
More specifically this function will construct the instance identifier (\uri) from a set of attributes from the streams and relations.
In this case the expression $\Phi$ has a declarative representation of the form:
\begin{align*}
\Phi_{S_1,\ldots,S_n}(\vec{x})=\exists\vec{y}.p^{Proj}_{S_1,\ldots,S_n}(\vec{x}) \wedge p^{Join}_{S_1,\ldots,S_n}(\vec{v}) \wedge p_{S_1,\ldots,S_n}^{Sel}(\vec{v})
%\mathcal{E}_C=\{f_C^{Id}(x.A_1,\dots,x.A_n,y.B_1,\dots ,y.B_m)\mid & S_1(x) \wedge S_2(y) \wedge e_C^{Join}(x,y) \\ & \wedge e_C^{Cond}(x) \wedge e_C^{Cond}(y)\}
\end{align*}
where $\vec{v}$ is a tuple of variables in either $\vec{x},\vec{y}$. 
The term $p^{Join}$ denotes a set of join conditions over the streams and relations $S_i$. 
Similarly the term $p^{Sel}$ represents a set of condition predicates over the variables $\vec{v}$ in the streams $S_i$ (\eg conditions using $<,\leq,\geq,>,=$ operators).
\\
%For instance a class $C_1$ that is mapped to a stream $S_1$ joined to a relation $S_2$, has a mapping assertion $C_1(f_{C_1}^Id(x,w)) \leadsto \Phi_{S_1,S_2}(x,w) = \exists y,z.S_1(x,y)\wedge S_2(z,w) \wedge y=z$. In this case the tuples of distinguished ($\vec{x}$) and non-distinguished variables ($\vec{y}$) are $(x,w)$ and $(y,z)$ respectively. The set of predicates $p^{Join}$ is ${y=z}$ and denotes a join between $S_1$ and $S_2$. Notice that in order to create instances of $C_1$ a function $f_{C_1}^{Id}(x,w)$ will be applied.
%

A mapping assertion $R(f_{C_1}^{Id}(\vec{x_1}),f_{C_2}^{Id}(\vec{x_2})) \leadsto \Phi_{S_1,\ldots,S_n}(\vec{x_1},\vec{x_2})$ describes how to construct instances of the object property $R$ from the source streams and relations $S_i$. 
The declarative form of $\Phi$ is:
\begin{align*}
\Phi_{S_1,\ldots,S_n}(\vec{x_1},\vec{x_2})= &\exists\vec{y}.\Phi_{S_1,\ldots,S_k}(\vec{x_1}) \\
& \wedge \Phi_{S_{k+1},\ldots,S_n}(\vec{x_2}) \wedge p_{S_1,\ldots,S_n}^{Join}(\vec{v})
%
%(x.A_1,\dots,x.A_n,y.B_1,\dots ,y.B_m) \mid & \mathcal{E}_{C_1}(x) \wedge \mathcal{E}_{C_2}(y) \wedge \\ & \exists z_1,\dots ,z_p(AUX_1(z_1) \wedge \dots \wedge AUX_p(z_p) \\ & \wedge e_R^{Join}(x,y,z_1,\dots,z_p) \\ & \wedge e_R^{Cond}(x,y,z_1,\dots,z_p)) \}
\end{align*}
%where  $\vec{x},\vec{y}$ are the tuples of distinguished and non distinguished variables respectively. $\vec{v}$ is a tuple of variables in either $\vec{x}$ or $\vec{y}$.
where $\Phi_{S_1,\ldots,S_k}, \Phi_{S_{k+1},\ldots,S_n}$ describe how to extract instances of $C_1$ and $C_2$ from the streams $S_1,\ldots,S_k$ and $S_{k+1},\ldots,S_n$ respectively. 
The term $p^{Join}$ is the set of predicates that denotes the join between the streams and relations $S_1,\ldots,S_n$.

Finally an expression $A(f_C^{Id}(\vec{x}),f_A^{Trf}(\vec{z})) \leadsto \Phi_{S_1,\ldots,S_n}(\vec{x},\vec{z})$ describes how to construct instances of the datatype property $A$ from the source streams and relations $S_1,\ldots,S_n$. 
The function $f_A^{Trf}$ executes any transformation over the tuple of variables $\vec{z}$ to obtain the property value (\eg arithmetic operations, or string operations). 
The declarative form of $\Phi$ in this case is:
\begin{align*}
\Phi_{S_1,\ldots,S_n}(\vec{x},\vec{z})= &\exists\vec{y}.\Phi_{S_1,\ldots,S_k}(\vec{x})  \\
&\wedge \Phi_{S_{k+1},\ldots,S_n}(\vec{z}) \wedge p_{S_1,\ldots,S_n}^{Join}(\vec{v})
%
%\{E}_A=\{f_C^{Id}f_A^{Trf}(x.A_1,\dots,x.A_n,x.b_1,\dots,x.b_m)\mid \mathcal{E}_C(x)  \wedge e_A^{Cond}(x) \}
\end{align*}
The definition follows the same idea as the previous one. 
The variables of $\vec{z}$ will contain the actual values that will be used to construct the datatype property value using the function $f_A^{Trf}$.

When a conjunctive query is issued against the global ontology, the processor first parses it and transforms it into an abstract syntax tree and then uses the expansion algorithm described in \cite{Barrasa_04} (that is based on the \textsf{PerfectRef} algorithm of \cite{Calvanese_05}) to produce an expanded conjunctive query based on the TBox of the ontology. 
Afterwards the rewritten query can be translated to an extended relational algebra.

A query $Q_{\mathcal{O}}(\vec{x})[t_s,t_e,\delta]$ is a conjunctive query with a window operator (where $t_s$, $t_e$ are the start and end points of the window range and $\delta$ is the slide) in order to narrow the data set according to a given criteria. 
For a query:
\begin{equation*}
  Q_{\mathcal{O}}(\vec{x})[t_s,t_e,\delta] = (C_1(x) \wedge R(x,y) \wedge A(x,z)) [t_s,t_e,\delta]
\end{equation*}
%\fixme{Should the window be applied to each of $C_1$, $R$, and $A$?}
the translation is given by $\lambda(\Phi)$, following the mapping definition:
\begin{align*}
\lambda(\Phi_{S_1,\ldots,S_n}(\vec{x}) {\scriptstyle [t_s,t_e,\delta]}
)=\pi_{p^{Proj}}(\Join_{p^{Join}}
(&\sigma_{p^{Sel}}(\omega_{t_s,t_e,\delta}S_1),\dots \\ &,\sigma_{p^{Sel}}(\omega_{t_s,t_e,\delta}S_n)))
\end{align*}
The expression denotes first a window operation $\omega_{t_s,t_e,\delta}$ over the relations or streams $S_1,\dots, S_n$, with $t_s$, $t_e$, and $\delta$ being the time range and slide. 
A selection $\sigma_{p^{Sel}}$ is applied over the result, according to the conditions defined in the mapping. 
A multi-way join $\Join_{p^{Join}}$ is then applied to the selection, also based on the corresponding mapping definition. 
Finally a projection $\pi_{p^{Proj}}$ is applied over the results. 
For any conjunctive query with more atoms, the construction of the algebra expression will follow the same direct translation using the \gav approach.
%
%For a query $Q_O$ of the form $C(f_C^{Id}(\vec{x}))[t_i,t_f,\delta]$ the translation is given by $\lambda(\Phi)$, following the mapping definition:
%\begin{align*}
%\lambda(\Phi_{S_1,\ldots,S_n}(\vec{x})[t_i,t_f,\delta])=\pi_{p^{Proj}}(\Join_{p^{Join}}
%(&\sigma_{p^{Sel}}(\omega_{t_i,t_f,\delta}S_1),\dots \\ %&,\sigma_{p^{Sel}}(\omega_{t_i,t_f,\delta}S_n)))
%\end{align*}
%The expression denotes first a window operation $\omega_{t_i,t_f,\delta}$ over the relations or streams $S_1,\dots ,S_n$, with $t_i..t_f$ and $\delta$ being the range and slide. A selection $\sigma_{p^{Sel}}$ is applied over the result, with the conditions defined in the mapping.  A multiple join $\Join_{p^{Join}}$ is then applied to the selection, also based on the corresponding mapping definition. Finally a projection $\pi_{p^{Proj}}$ is applied over the results.
%\\
%For a query $Q_O$ of the form $C(f_C^{Id}(\vec{x}) \wedge A(f_C^{Id}(\vec{x}),f_A^{Trf}(\vec{z})) [t_i,t_f,\delta]$ the translation is given by:
%\begin{align*}
%\lambda(\Phi_{S_1,\ldots,S_n}(\vec{x},\vec{z})[t_i,t_f,\delta])=\pi_{p^{Proj}}(\Join_{p^{Join}}
%&(\sigma_{p^{Sel}}(\omega_{t_i,t_f,\delta}S_1),\dots \\ %&,\sigma_{p^{Sel}}(\omega_{t_i,t_f,\delta}S_n)))
%\end{align*}
%Similarly to the previous case, the window, selection, join and projection operations are applied to the source relations and streams according to the mapping definition. Additionally, the $f_A^{Trf}$ is applied over the resulting attributes in case of any necessary transformations.\\
%For a query $Q_O$ of the form $C_1(f_{C_1}^{Id}(\vec{x})) \wedge R(f_{C_1}^{Id}(\vec{x}),f_{C_2}^{Id}(\vec{x})) \wedge C_2(f_{C_2}^{Id}(\vec{y}))$ the translation is given by:
%\begin{align*}
%\lambda(\Phi_{S_1,\ldots,S_n}(\vec{x_1},\vec{x_2})[t_i,t_f,\delta])=\pi_{p^{Proj}}( \Join_{p^{Join}}
%&(  \sigma_{p^{Sel}} (\omega_{t_i,t_f,\delta}S_1),\dots ,\\
%&\sigma_{p^{Sel}} (\omega_{t_i,t_f,\delta}S_n)))
%\end{align*}
%As in the previous cases, the logical operators are applied following the mapping definition $\mathcal{M}$.

%Then I explain semantics of mappings. based on barrasa thesis. try to align in some way to odba. put emphasis on the additions to mappings semantics exlpain perfect reform algorithm, explain translation to sneeql

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rere"
%%% End: 
