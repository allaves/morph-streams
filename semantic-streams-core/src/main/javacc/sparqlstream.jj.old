// ARQ/SPARQL Grammar - native syntax for the query engine
// Author:  Andy Seaborne andy.seaborne@hp.com
// (c) Copyright 2004, 2005, 2006, 2007 Hewlett-Packard Development Company, LP
// All rights reserved.
// See end of file for details.
//
// Constraint expression is derived from Java : 
// example java1.2-a.jj grammer in JavaCC distribution
// Much modifed over time.
// J-P Calbimonte - sparql-stream additions

options
{
   LOOKAHEAD = 6;
   FORCE_LA_CHECK = true;
   JAVA_UNICODE_ESCAPE = true ;
   UNICODE_INPUT = false ;
   /*OUTPUT_DIRECTORY = "com/hp/hpl/jena/sparql/lang/sparql";*/

  	STATIC = false ;
//  DEBUG_PARSER          = true ;
//  DEBUG_TOKEN_MANAGER   = true ;
}

PARSER_BEGIN(SPARQLStrParser)
/*
 * (c) Copyright 2004, 2005, 2006, 2007 Hewlett-Packard Development Company, LP
 * All rights reserved.
 */

package es.upm.fi.dia.oeg.sparql.lang.sparqlstream ;

import com.hp.hpl.jena.graph.* ;
import com.hp.hpl.jena.query.* ;
import com.hp.hpl.jena.sparql.syntax.* ;
import com.hp.hpl.jena.sparql.expr.* ;
import com.hp.hpl.jena.sparql.core.Var;
import es.upm.fi.dia.oeg.sparqlstream.AggregateType;
import es.upm.fi.dia.oeg.sparqlstream.WindowType;
import es.upm.fi.dia.oeg.sparqlstream.syntax.WindowUnit;
import es.upm.fi.dia.oeg.sparqlstream.ExprTimestamp;
import es.upm.fi.dia.oeg.sparqlstream.syntax.ElementAggregate;
import es.upm.fi.dia.oeg.sparqlstream.syntax.ElementFunction;
import es.upm.fi.dia.oeg.sparqlstream.syntax.ElementStream;
import es.upm.fi.dia.oeg.sparqlstream.syntax.ElementTimeWindow;
import es.upm.fi.dia.oeg.sparqlstream.syntax.ElementTripleWindow;
import es.upm.fi.dia.oeg.sparqlstream.syntax.ElementWindow;
import es.upm.fi.dia.oeg.sparqlstream.syntax.ExpressionTimeValue;
import es.upm.fi.dia.oeg.sparqlstream.syntax.FunctionType;
import es.upm.fi.dia.oeg.sparqlstream.syntax.TimeValue;


public class SPARQLStrParser extends SPARQLStrParserBase
{
}
PARSER_END(SPARQLStrParser)

void CompilationUnit(): { }
{
  Query() <EOF>
}

void Query() : { }
{
  (RegisterStream())?
  Prologue()
  ( SelectQuery() | ConstructQuery() | DescribeQuery() | AskQuery() )
}

void RegisterStream() : { Token t ;}
{
  <REGISTER> t= <STNAME>
}

void Prologue() : {}
{
  ( BaseDecl() ) ?
  ( PrefixDecl() )*
}

void BaseDecl() : { String n ; }
{
  <BASE> n = IRI_REF()
  { getQuery().setBaseURI(n) ; }
}


void PrefixDecl() : { Token t ; String n ; }
{
    <PREFIX> t = <PNAME_NS> n = IRI_REF()
      { String s = fixupPrefix(t.image, t.beginLine, t.beginColumn) ;
        getQuery().setPrefix(s, n) ; }
}

// ---- Query type clauses

void SelectQuery() : { Node v = null; Node v2 = null; ElementAggregate agg; ElementFunction fun; Expr c; }
{
  <SELECT>
    { getQuery().setQuerySelectType() ; }
  ( <DISTINCT> { getQuery().setDistinct(true);}
  | <REDUCED> { getQuery().setReduced(true); }
  )?
  (
    (( v = Var() { getQuery().addResultVar(v) ; } )
    |
     ( agg = Aggregate(v,v2) 
   		{ 	getQuery().addResultVar(agg.getVar());
   			getStreamQuery().addAggregate(agg); 
   		} 
   	  )
   	|
   	  ( fun = Function(v,v2) 
   		{ 	
   		getQuery().addResultVar(fun.getVar());   		
   		getStreamQuery().addFunction(fun);
   		//getQuery().addResultVar(fun.getVar(),new ExprTimestamp(new ExprVar(fun.getParameterVar().getName())));
   			//getQuery().addResultAggregation(agg); 
   		} 
   	  )
   	|
   	  ( c = BrackettedExpression() <AS> v = Var() 
   		{ 
   		getQuery().addResultVar(v,c);
   		//getQuery().addResultVar(fun.getVar());
   		//getStreamQuery().addFunction(fun);
   		} 
   	  )
   	
   	 
    )+
    { getQuery().setQueryResultStar(false) ; }
  |
    <STAR> { getQuery().setQueryResultStar(true) ; }
  )
//try
//{
  [ FromClause() ]
//  } catch (TokenMgrError e)
//  {
//  System.out.println("tacha");
 // }
  WhereClause()
  [ GroupBy() ]
  /* [ Having() ] */
  SolutionModifier()
}

void ConstructQuery() : { Template t ; }
{
  <CONSTRUCT>
    { getQuery().setQueryConstructType() ;
      setInConstructTemplate(true) ; }
  t = ConstructTemplate()
    { setInConstructTemplate(false) ;
      getQuery().setQueryResultStar(false) ;
      getQuery().setConstructTemplate(t) ; }
  [ FromClause() ]
  WhereClause()
  SolutionModifier()
}

void DescribeQuery() : { Node n ; }
{
  <DESCRIBE>
    { getQuery().setQueryDescribeType() ; }
  (
    ( n = VarOrIRIref() { getQuery().addDescribeNode(n) ; } )+
    { getQuery().setQueryResultStar(false) ; }
  |
    <STAR>
    { getQuery().setQueryResultStar(true) ; }
  )
  [ FromClause() ]
  ( WhereClause() )?
  SolutionModifier()
}

void AskQuery() : {}
{
  <ASK> { getQuery().setQueryAskType() ; }
  [ FromClause() ]
  WhereClause()
}

// ----

// This non terminal defines a FROM-part in a sparql query.
// It can contain persistent rdf sources or rdf streams but
// not both.

void FromClause() : {}
{
  ( DatasetClause() | DataStreamClause())
}

void DatasetClause() : {}
{
  {
    //getQuery().setStreamQuery(false);
  }
  ( <FROM> DefaultGraphClause() | <FROM> NamedGraphClause() )+
}

void DataStreamClause() : {}
{
  {
    //getQuery().setStreamQuery(true);
  }
  ( <FROM> NamedStreamClause() )+
}

void DefaultGraphClause() : { String n ; }
{
  n = SourceSelector()
  {
    getQuery().addGraphURI(n) ;
  }
}

void NamedGraphClause() : { String n ; }
{
  <NAMED>
  n = SourceSelector()
  {
    // This checks for duplicates
    getQuery().addNamedGraphURI(n) ;
  }
}

void NamedStreamClause() : 
{ 
    String n;
    ElementWindow w = null;
    ElementStream ds;
}
{
  <NAMED> <STREAM>
  n = SourceSelector()
  (	<LBRACKET>
  		(w = Window()
  		//|
  		//({System.out.println("sadada");})
  		)
	<RBRACKET>)? 
  {
    ds = new ElementStream();
    //ds.setNamed(false);
    ds.setUri(n);
    ds.setWindow(w);
    getStreamQuery().addStream(ds);
  }
}

ElementFunction Function(Node v,Node v2) : {ElementFunction fun ;}

{
	(<TIMESTAMP> <LPAREN> v = Var() <RPAREN> <AS> v2 = Var()
	//(<TIMESTAMP> <LPAREN> v = Var() <RPAREN> 
	 	{ 	//v = Var.alloc("COUNT("+v.getName()+")");
	 		fun = new ElementFunction(v2, v,FunctionType.TIMESTAMP); }
	)
	{return fun;}	
}



ElementAggregate Aggregate(Node v,Node v2) : {ElementAggregate agg ;}
{
	(<AVG> <LPAREN> v = Var() <RPAREN> <AS> v2 = Var()
		{ 	//v = Var.alloc("AVG("+v.getName()+")"); 
			agg = new ElementAggregate(v,v2, AggregateType.AVG); } |
	 <COUNT> <LPAREN> v = Var() <RPAREN> <AS> v2 = Var()
	 	{ 	//v = Var.alloc("COUNT("+v.getName()+")");
	 		agg = new ElementAggregate(v,v2, AggregateType.COUNT); } |
	 <MAX> <LPAREN> v = Var() <RPAREN> <AS> v2 = Var()
	 	{ 	//v = Var.alloc("MAX("+v.getName()+")");
	 		agg = new ElementAggregate(v,v2, AggregateType.MAX); } |
	 <MIN> <LPAREN> v = Var() <RPAREN> <AS> v2 = Var()
		{ 	//v = Var.alloc("MIN("+v.getName()+")");
			agg = new ElementAggregate(v,v2, AggregateType.MIN); } |
	 <SUM> <LPAREN> v = Var() <RPAREN> <AS> v2 = Var()
	 	{ 	//v = Var.alloc("SUM("+v.getName()+")");
	 		agg = new ElementAggregate(v,v2, AggregateType.SUM); } 
	)
	{return agg;}
}

ElementWindow Window() : {ElementWindow ew = null;}
{
  ( ew = TimeWindow() | ew = TripleWindow() )
  {return ew;}
}

ElementTimeWindow TimeWindow() : 
{
    ExpressionTimeValue rangeto = null;
    ExpressionTimeValue from = null;
    ElementTimeWindow stw = null;
    TimeValue range = null;
    TimeValue delta = null;}
{
  {stw = new ElementTimeWindow(WindowType.TIME_WINDOW);}
  
  from = TimeExpression() [<TO> rangeto = TimeExpression()]
  [(<SLIDE> {}) ( delta = ValueSpecification())?]
  {
    if(delta != null){
        stw.setSlide(delta);
    }
    else{
        stw.setDelta(1, from.getUnit());
    }
    stw.setFrom(from);
    if (rangeto != null)
    {	
      stw.setTo(rangeto);
    }
    return stw;
  }
}



ElementTripleWindow TripleWindow() : {ElementTripleWindow tw = null; Token t = null;}
{
  <TRIPLES> t = <INTEGER>
  { int elems = Integer.parseInt(t.toString());
    tw = new ElementTripleWindow(WindowType.TRIPLE_WINDOW);
    tw.setRange(elems, WindowUnit.TRIPLE);
    tw.setDelta(1, WindowUnit.TRIPLE);
    return tw;
  }
}


TimeValue ValueSpecification() : 
{
    TimeValue vs = null;
    Token t = null;
    WindowUnit timeunit = null;
}
{
  t = <INTEGER> [timeunit = GetUnit()]
  { long longValue = Integer.parseInt(t.toString());
    vs = new TimeValue(longValue, timeunit);
    return vs;}
}

ExpressionTimeValue TimeExpression() : 
{
    ExpressionTimeValue vs = null;
    Token t = null;
    WindowUnit timeunit = null;
}
{
//try{
  (<NOW> <MINUS> t = <INTEGER> [timeunit = GetUnit()]
  | <NOW>)
//  }
//  catch (TokenMgrError e)
//  {
//  	System.out.println("lachafa");
//  }
  { long longValue = 0;
  	if (t!=null)
  	{
  		longValue = Integer.parseInt(t.toString());
  	}
    vs = new ExpressionTimeValue(longValue,timeunit);
    return vs;
  }
}

WindowUnit GetUnit(): {WindowUnit timeunit;}
{
  ( <MS>     {timeunit = WindowUnit.MILLISECOND;}
  | <S>  	 {timeunit = WindowUnit.SECOND;}  
  | <SECOND> {timeunit = WindowUnit.SECOND;}  
  | <MINUTE> {timeunit = WindowUnit.MINUTE;}
  | <HOUR> 	 {timeunit = WindowUnit.HOUR;} 
  | <DAY> 	 {timeunit = WindowUnit.DAY;}
  | <MONTH>  {timeunit = WindowUnit.MONTH;}
  | <YEAR> 	 {timeunit = WindowUnit.YEAR;}
  )
  {return timeunit;}

}


String SourceSelector() : { String n ; }
{
  n = IRIref()
  { //if ( ! n.isURI() )
    //    throw new QueryParseException("Not an URI: "+n.toString(),
    //                                  token.beginLine, token.beginColumn) ;
    return n ;
  }
}


void WhereClause() : { Element el ; }
{
   (<WHERE>)? el = GroupGraphPattern() { getQuery().setQueryPattern(el) ; }
}

void GroupBy() : { Node v; }
{
	<GROUP> <BY> <LPAREN> ( v = Var() { getQuery().addGroupBy(v); } )+ <RPAREN>
}

void SolutionModifier() : { }
{
  ( OrderClause() )?
  ( LimitOffsetClauses() )?
}

void LimitOffsetClauses() : { }
{
  // SPARQL does not care about the order here.
  // SQL (where implemented) does (it's LIMIT then OFFSET generally)
  // But that is counter intuitive as it's applied the other way round
  (
    LimitClause() (OffsetClause())?
  |
    OffsetClause() (LimitClause())?
  )
}



void OrderClause() : { }
{
  <ORDER> <BY> ( OrderCondition() )+
}

void OrderCondition() :
{ int direction = 0 ; Expr expr = null ; Node v = null ; }
{
  { direction = Query.ORDER_DEFAULT ; }
  (
    ( // These are for clarity in the HTML
      ( <ASC> { direction = Query.ORDER_ASCENDING ; }
      | <DESC> { direction = Query.ORDER_DESCENDING ; } )
      expr = BrackettedExpression()
    )
  |
    ( expr = Constraint()
    | v = Var() //{ expr = asExpr(v) ; } 
    )
  )
  { if ( v == null )
          getQuery().addOrderBy(expr, direction) ;
      else
          getQuery().addOrderBy(v, direction) ; }
}

void LimitClause() : { Token t ; }
{
  <LIMIT> t = <INTEGER>
    { getQuery().setLimit(integerValue(t.image)) ; }
}

void OffsetClause() : { Token t ; }
{
  <OFFSET> t = <INTEGER>
    { getQuery().setOffset(integerValue(t.image)) ; }
}

// ---- General Graph Pattern 

Element GroupGraphPattern() : { Element el = null ; ElementWindow ew = null;}
{
    { ElementGroup elg = new ElementGroup() ; }
  <LBRACE>
      { startGroup(elg) ; }
  // Ensure two BGP's can't be next to each other
  // Done by seeing if there is a non-BGP and recursing
  // if there is an intermediate
  (
    { startTriplesBlock() ; }
    el = TriplesBlock(null)
    { endTriplesBlock() ;
      elg.addElement(el) ; }
  )?
  (
    ( el = GraphPatternNotTriples() | el = Filter() )
    { elg.addElement(el) ; }
    (<DOT>)?

    (
      { startTriplesBlock() ; }
      el = TriplesBlock(null)
      { endTriplesBlock() ;
        elg.addElement(el) ; }
    )?
  )*

  //( ew = WindowNotPWindow() {elg.setWindow(ew);})?
      { endGroup(elg) ; }
  <RBRACE>
    { return elg ; }
}

Element TriplesBlock(ElementTriplesBlock acc) : { }
{
  { if ( acc == null )
      acc = new ElementTriplesBlock() ;
  }
  TriplesSameSubject(acc)
  ( <DOT> (TriplesBlock(acc))? )?
    { return acc ; }
}

// @@ Ready to be deleted
// Element GroupGraphPattern() : { Element el = null ; ElementTriplesBlock acc = null ; }
// {
//     { ElementGroup elg = new ElementGroup() ; }
//   <LBRACE>
//       { startGroup(elg) ; }
//   // Ensure two BGP's can't be next to each other
//   // Done by seeing if there is a non-BGP and recursing
//   // if there is an intermediate
//   (
//     { acc = new ElementTriplesBlock() ;
//       startTriplesBlock(acc) ;
//     }
//     el = TriplesBlock(acc)
//     { endTriplesBlock(acc) ;
//       elg.addElement(el) ; } 
//   )?
//   (
//     ( el = GraphPatternNotTriples() | el = Filter() )
//     { elg.addElement(el) ; }
//     (<DOT>)?
// 
//     (
//       { acc = new ElementTriplesBlock() ;
//         startTriplesBlock(acc) ;
//       }
//       el = TriplesBlock(acc)
//       { endTriplesBlock(acc) ;
//         elg.addElement(el) ; } 
//     )?
//   )*
//       { endGroup(elg) ; }
//   <RBRACE>
//     { return elg ; }
// }

// Element GroupGraphPattern() : {}
// {
//     { ElementGroup elg = new ElementGroup() ; }
//   <LBRACE>
//       { startGroup(elg) ; }
//     GraphPatternElement(elg)
//       { endGroup(elg) ; }
//   <RBRACE>
//     { return elg ; }
// }
// 
// 
// // Without {}
// // If the recusion is removed can roll GraphPatternElement into GroupGraphPattern()
// 
// void GraphPatternElement(ElementGroup elg) : 
//     { Element el = null ; ElementTriplesBlock acc = null ; }
// {
//   // Ensure two BGP's can't be next to each other
//   // Done by seeing if there is a non-BGP and recursing
//   // if there is an intermediate
//   (
//     { acc = new ElementTriplesBlock() ;
//       startTriplesBlock(acc) ;
//     }
//     el = TriplesBlock(acc)
//     { endTriplesBlock(acc) ;
//       elg.addElement(el) ; } 
//   )?
//   (
//     ( el = GraphPatternNotTriples()
//     | el = Filter()                 
//     )
//     { elg.addElement(el) ; }
//     (<DOT>)?
//     GraphPatternElement(elg)
//   )?
// }
// 
// 
// Element TriplesBlock(ElementTriplesBlock acc) : { }
// {
//   { if ( acc == null )
//       acc = new ElementTriplesBlock() ;
//   }
//   TriplesSameSubject(acc)
//   ( <DOT> (TriplesBlock(acc))? )?
//     { return acc ; }
// }


// -----

Element GraphPatternNotTriples() : { Element el = null ; }
{
 (
   el = OptionalGraphPattern()
 |
   // "GroupPattern" or "GroupPattern" union "GroupPattern"
   el = GroupOrUnionGraphPattern()
 |
   el = GraphGraphPattern()




 )
  { return el ; }
}

// ---- Definitions of each pattern element

Element OptionalGraphPattern() : { Element el ; }
{ <OPTIONAL> el = GroupGraphPattern()
    { return new ElementOptional(el) ; }
}

Element GraphGraphPattern() : { Element el ; Node n ;}
{
  <GRAPH> n = VarOrIRIref() el = GroupGraphPattern()
    { return new ElementNamedGraph(n, el) ; }
}

// G (union G)* can be a single group pattern
// or a group pattern as part of an union.
Element GroupOrUnionGraphPattern() :
{ Element el = null ; ElementUnion el2 = null ; }
{
  el = GroupGraphPattern()
  ( <UNION>
    { if ( el2 == null )
      {
        el2 = new ElementUnion() ;
        el2.addElement(el) ;
      }
    }
  el = GroupGraphPattern()
    { el2.addElement(el) ; }
  )*
    { return (el2==null)? el : el2 ; }
}
Element Filter() : { Expr c ; }
{
  <FILTER> c = Constraint()
  { return new ElementFilter(c) ; }
}

Expr Constraint() : { Expr c ; }
{
  ( c = BrackettedExpression()
  | c = BuiltInCall()
  | c = FunctionCall()
  )
  { return c ; }
}


Expr FunctionCall() : { String fname ; ExprList a ; }
{
  fname = IRIref() a = ArgList()
    { return new E_Function(fname, a) ; }
}

ExprList ArgList() : { Expr expr ; ExprList args = new ExprList() ; }
{
  (
    <NIL>
  |
   // Was <LPAREN> ( Expression() (<COMMA> Expression() )* )? <RPAREN>
    <LPAREN>
      expr = Expression() { args.add(expr) ; }
      (<COMMA> expr = Expression() { args.add(expr) ; } )*
    <RPAREN>
   )
    { return args ; }
}

// -------- Construct patterns

Template ConstructTemplate() : { }
{
    { TemplateGroup g = new TemplateGroup() ; }
  <LBRACE>
    (ConstructTriples(g))?
  <RBRACE>
    { return g ; }
}

void ConstructTriples(TemplateGroup acc) : { }
{
    TriplesSameSubject(acc)
    (<DOT> (ConstructTriples(acc))? )?
}

// -------- Triple lists with property and object lists

void TriplesSameSubject(TripleCollector acc) : { Node s ; }
{
  s = VarOrTerm()
  PropertyListNotEmpty(s, acc)
|
  // Any of the triple generating syntax elements
  s = TriplesNode(acc)
  PropertyList(s, acc)
}

void PropertyListNotEmpty(Node s, TripleCollector acc) : { Node p ; }
{
  p = Verb()
  ObjectList(s, p, acc)
  (<SEMICOLON> (p = Verb() ObjectList(s, p, acc))? )*

}

void PropertyList(Node s, TripleCollector acc) : { }
{
  ( PropertyListNotEmpty(s, acc) ) ?
}

// // Recursive
// void PropertyListNotEmpty(Node s, TripleCollector acc) : { Node p ; }
// {
//   p = Verb()
//   ObjectList(s, p, acc)
//   (<SEMICOLON> PropertyList(s, acc) ) ?
// #ifdef ARQ
//   |
//   Reification(s, acc)
// #endif
// }

// // Recursive
// void ObjectList(Node s, Node p, TripleCollector acc): { Node o ; } 
// {
//     { int mark = acc.mark() ; }
//   o = GraphNode(acc) 
//     { insert(acc, mark, s, p, o) ; }
//   ( <COMMA> ObjectList(s, p , acc) )?
// }

void ObjectList(Node s, Node p, TripleCollector acc): { Node o ; }
{
  Object(s, p, acc)
  ( <COMMA> Object(s, p, acc) )*
}

void Object(Node s, Node p, TripleCollector acc): { Node o ; }
{
    { int mark = acc.mark() ; }
  o = GraphNode(acc)
  { insert(acc, mark, s, p, o) ; }
}

Node Verb() : {Node p ;}
{
//   ( p = VarOrBlankNodeOrIRIref() | <KW_A> { p = nRDFtype ; } )
  ( p = VarOrIRIref() | <KW_A> { p = nRDFtype ; } )
    { return p ; }
}

// -------- Triple expansions

// Anything that can stand in a node slot and which is
// a number of triples

Node TriplesNode(TripleCollector acc) : { Node n ; }
{
  n = Collection(acc) { return n ; }
 |
  n = BlankNodePropertyList(acc) { return n ; }




}

Node BlankNodePropertyList(TripleCollector acc) : { }
{
  <LBRACKET>
    { Node n = createBNode() ; }
  PropertyListNotEmpty(n, acc)
  <RBRACKET>
    { return n ; }
}
// ------- RDF collections

Node Collection(TripleCollector acc) :
    { Node listHead = nRDFnil ; Node lastCell = null ; int mark ; Node n ; }
{
  <LPAREN>
  (
    { Node cell = createListNode() ;
      if ( listHead == nRDFnil )
         listHead = cell ;
      if ( lastCell != null )
        insert(acc, lastCell, nRDFrest, cell) ;
      mark = acc.mark() ;
    }
    n = GraphNode(acc)
    {
      insert(acc, mark, cell, nRDFfirst, n) ;
      lastCell = cell ;
    }
  ) +
  // Not * here - "()" is handled separately.
  <RPAREN>
   { if ( lastCell != null )
       insert(acc, lastCell, nRDFrest, nRDFnil) ;
     return listHead ; }
}

// -------- Nodes in a graph pattern or template

Node GraphNode(TripleCollector acc) : { Node n ; }
{
  n = VarOrTerm() { return n ; }
 |
  n = TriplesNode(acc) { return n ; }
}

Node VarOrTerm() : {Node n = null ; }
{
  ( n = Var() | n = GraphTerm() )
  { return n ; }
}

// Property (if no bNodes) + DESCRIBE
Node VarOrIRIref() : {Node n = null ; String iri; }
{
  iri = IRIref() {return createNode(iri);}
  | n = Var() {return n;}   
}

// // GRAPH and property if including blank nodes are properties.
// Node VarOrBlankNodeOrIRIref() : {Node n = null ; }
// {
//   ( n = Var() | n = BlankNode() | n = IRIref() )
//   { return n ; }
// }

Node Var() : { Token t ;}
{
    ( t = <VAR1> | t = <VAR2> )
    { return createVariable(t.image, t.beginLine, t.beginColumn) ; }
}

Node GraphTerm() : { Node n ; String iri; }
{
  iri = IRIref() { return createNode(iri) ; }
| n = RDFLiteral() { return n ; }
| n = NumericLiteral() { return n ; }
| n = BooleanLiteral() { return n ; }
| n = BlankNode() { return n ; }
  //  <LPAREN> <RPAREN>     { return nRDFnil ; }
| <NIL> { return nRDFnil ; }
}

// -------- Constraint syntax

Expr Expression() : { Expr expr ; }
{
  expr = ConditionalOrExpression()
  { return expr ; }
}

Expr ConditionalOrExpression() : { Expr expr1, expr2 ; }
{
  expr1 = ConditionalAndExpression()
  ( <SC_OR> expr2 = ConditionalAndExpression()
    { expr1 = new E_LogicalOr(expr1, expr2) ; }
  )*
    { return expr1 ; }

}

Expr ConditionalAndExpression() : { Expr expr1, expr2 ;}
{
  expr1 = ValueLogical()
  ( <SC_AND> expr2 = ValueLogical()
    { expr1 = new E_LogicalAnd(expr1, expr2) ; }
  )*
    { return expr1 ; }
}

Expr ValueLogical() : { Expr expr ; }
{
  expr = RelationalExpression()
    { return expr ; }
}

Expr RelationalExpression() : { Expr expr1, expr2 ; }
{
  expr1 = NumericExpression()
  (
    <EQ> expr2 = NumericExpression()
      { expr1 = new E_Equals(expr1, expr2) ; }
  | <NE> expr2 = NumericExpression()
      { expr1 = new E_NotEquals(expr1, expr2) ; }
  | <LT> expr2 = NumericExpression()
      { expr1 = new E_LessThan(expr1, expr2) ; }
  | <GT> expr2 = NumericExpression()
      { expr1 = new E_GreaterThan(expr1, expr2) ; }
  | <LE> expr2 = NumericExpression()
      { expr1 = new E_LessThanOrEqual(expr1, expr2) ; }
  | <GE> expr2 = NumericExpression()
      { expr1 = new E_GreaterThanOrEqual(expr1, expr2) ; }
  )?
    { return expr1 ; }
}

Expr NumericExpression () : { Expr expr ; }
{
  expr = AdditiveExpression()
    { return expr ; }
}

Expr AdditiveExpression() : { Expr expr1, expr2 ; Node n ; }
{
  expr1 = MultiplicativeExpression()
  ( <PLUS> expr2 = MultiplicativeExpression()
    { expr1 = new E_Add(expr1, expr2) ; }
  | <MINUS> expr2 = MultiplicativeExpression()
    { expr1 = new E_Subtract(expr1, expr2) ; }
  | n = NumericLiteralPositive()
    {
      n = stripSign(n) ;
      expr2 = asExpr(n) ;
      expr1 = new E_Add(expr1, expr2) ;
    }
  |
    n = NumericLiteralNegative()
    {
      n = stripSign(n) ;
      expr2 = asExpr(n) ;
      expr1 = new E_Subtract(expr1, expr2) ;
    }
  )*
    { return expr1 ; }
}

Expr MultiplicativeExpression() : { Expr expr1, expr2 ; }
{
  expr1 = UnaryExpression()
  ( <STAR> expr2 = UnaryExpression()
    { expr1 = new E_Multiply(expr1, expr2) ; }
  | <SLASH> expr2 = UnaryExpression()
    { expr1 = new E_Divide(expr1, expr2) ; }
//   | <REM>   expr2 = UnaryExpression()
//     { expr1 = new E_Modulus(expr1, expr2) ; }
  )*
    { return expr1 ; }
}

Expr UnaryExpression() : { Expr expr ; }
{
  <BANG> expr = PrimaryExpression()
    { return new E_LogicalNot(expr) ; }
  | <PLUS> expr = PrimaryExpression() { return new E_UnaryPlus(expr) ; }
  | <MINUS> expr = PrimaryExpression() { return new E_UnaryMinus(expr) ; }
  | expr = PrimaryExpression() { return expr ; }
}

Expr PrimaryExpression() : { Expr expr ; Node gn ; }
{
  ( expr = BrackettedExpression() { return expr ; }
  | expr = BuiltInCall() { return expr ; }
  | expr = IRIrefOrFunction() { return expr ; }

// NOT  | gn = VarOrTerm()           { return asExpr(gn) ; }
// Because of IRIrefOrFunction vs <NIL> and blank nodes
  | gn = RDFLiteral() { return asExpr(gn) ; }
  | gn = NumericLiteral() { return asExpr(gn) ; }
  | gn = BooleanLiteral() { return asExpr(gn) ; }
  | gn = Var() { return asExpr(gn) ; }
  )
}

Expr BrackettedExpression() : { Expr expr ; }
{
    <LPAREN> expr = Expression() <RPAREN> { return expr ; }
}

Expr BuiltInCall() : { Expr expr ; Expr expr1, expr2 ; Node gn ; Token t ;}
{
    // STR
    <STR> <LPAREN> expr = Expression() <RPAREN>
    { return new E_Str(expr) ; }
  | // Lang
    <LANG> <LPAREN> expr = Expression() <RPAREN>
    { return new E_Lang(expr) ; }
  |// Langmatches
    <LANGMATCHES>
       <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new E_LangMatches(expr1, expr2) ; }

  | // Datatype
    <DTYPE> <LPAREN> expr = Expression() <RPAREN>
    { return new E_Datatype(expr) ; }

  | <BOUND> <LPAREN> gn = Var() <RPAREN>
    { return new E_Bound(new ExprVar(gn)) ; }

  | <SAME_TERM> <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new E_SameTerm(expr1, expr2) ; }

  | t = <IS_IRI> <LPAREN> expr = Expression() <RPAREN>
    { return new E_IsIRI(expr) ; }

  | t = <IS_URI> <LPAREN> expr = Expression() <RPAREN>
    { return new E_IsURI(expr) ; }

  | <IS_BLANK> <LPAREN> expr = Expression() <RPAREN>
    { return new E_IsBlank(expr) ; }

  | <IS_LITERAL> <LPAREN> expr = Expression() <RPAREN>
    { return new E_IsLiteral(expr) ; }

  | // Regular expression matcher
    expr = RegexExpression() { return expr ; }
}

Expr RegexExpression() :
{ Expr expr ; Expr patExpr = null ; Expr flagsExpr = null ; }
{
    <REGEX> <LPAREN>
      expr = Expression()
      <COMMA>
      patExpr = Expression()
      ( <COMMA> flagsExpr = Expression() ) ?
    <RPAREN>
      { return new E_Regex(expr, patExpr, flagsExpr) ; }
}

// The case of "q:name()" or just "q:name"
// by expanding out FunctionCall()

Expr IRIrefOrFunction() : {String gn ; ExprList a = null ; }
{
  gn = IRIref()
  ( a = ArgList() )?
    { if ( a == null ) return asExpr(createNode(gn)) ;
      return new E_Function(gn, a) ;
    }
}

Node RDFLiteral() : { Token t ; String lex = null ; }
{
  lex = String()
  // Optional lang tag and datatype.
  { String lang = null ; String uri = null ; }
  (
    ( t = <LANGTAG> { lang = stripChars(t.image, 1) ; } )
  |
    ( <DATATYPE> uri = IRIref() )
  )?
    { return createLiteral(lex, lang, uri) ; }
}


Node NumericLiteral() : { Node n ; }
{
  (
    n = NumericLiteralUnsigned()
  | n = NumericLiteralPositive()
  | n = NumericLiteralNegative()
  )
  { return n ; }

}

Node NumericLiteralUnsigned() : { Token t ; }
{
  t = <INTEGER> { return createLiteralInteger(t.image) ; }
| t = <DECIMAL> { return createLiteralDecimal(t.image) ; }
| t = <DOUBLE> { return createLiteralDouble(t.image) ; }
}

Node NumericLiteralPositive() : { Token t ; }
{
  t = <INTEGER_POSITIVE> { return createLiteralInteger(t.image) ; }
| t = <DECIMAL_POSITIVE> { return createLiteralDecimal(t.image) ; }
| t = <DOUBLE_POSITIVE> { return createLiteralDouble(t.image) ; }
}

Node NumericLiteralNegative() : { Token t ; }
{
  t = <INTEGER_NEGATIVE> { return createLiteralInteger(t.image) ; }
| t = <DECIMAL_NEGATIVE> { return createLiteralDecimal(t.image) ; }
| t = <DOUBLE_NEGATIVE> { return createLiteralDouble(t.image) ; }
}


Node BooleanLiteral() : {}
{
  <TRUE> { return XSD_TRUE ; }
 |
  <FALSE> { return XSD_FALSE ; }
}

String String() : { Token t ; String lex ; }
{
  ( t = <STRING_LITERAL1> { lex = stripQuotes(t.image) ; }
  | t = <STRING_LITERAL2> { lex = stripQuotes(t.image) ; }
  | t = <STRING_LITERAL_LONG1> { lex = stripQuotes3(t.image) ; }
  | t = <STRING_LITERAL_LONG2> { lex = stripQuotes3(t.image) ; }
  )
    {
      lex = unescapeStr(lex, t.beginLine, t.beginColumn) ;
      return lex ;
    }
}

String IRIref() : { String n ; }
{
  n = IRI_REF() { return n ; }
|
  n = PrefixedName() { return n ; }
}

String PrefixedName() : { Token t ; }
{
  ( t = <PNAME_LN>
    { return resolvePName(t.image, t.beginLine, t.beginColumn) ; }
  |
    t = <PNAME_NS>
    { return resolvePName(t.image, t.beginLine, t.beginColumn) ; }
  )
}

Node BlankNode() : { Token t = null ; }
{
  t = <BLANK_NODE_LABEL>
    { return createBNode(t.image, t.beginLine, t.beginColumn) ; }
|
//  <LBRACKET> <RBRACKET> { return createBNode() ; }
  <ANON> { return createBNode() ; }

}

String IRI_REF() : { Token t ; }
{
  t = <IRIref>
  { return resolveQuotedIRI(t.image, t.beginLine, t.beginColumn) ; }
}

// ------------------------------------------
// Tokens

// Comments and whitespace

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN: { <#WS: " " | "\t" | "\n" | "\r" | "\f"> }

SPECIAL_TOKEN :
{ <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }

// Main tokens */

TOKEN:
{
   // Includes # for relative URIs
   <IRIref: "<" (~[ ">","<", "\"", "{", "}", "^", "\\", "|", "`",
                      "\u0000"-"\u0020"])* ">" >
| <STNAME: "STREAM:" <VARNAME> >
| <PNAME_NS: (<PN_PREFIX>)? ":" >
| <PNAME_LN: <PNAME_NS> <PN_LOCAL> >
| <BLANK_NODE_LABEL: "_:" <PN_LOCAL> >
| <VAR1: "?" <VARNAME> >
| <VAR2: "$" <VARNAME> >
| <LANGTAG: <AT> (<A2Z>)+("-" (<A2ZN>)+)* >
| <#A2Z: ["a"-"z","A"-"Z"]>
| <#A2ZN: ["a"-"z","A"-"Z","0"-"9"]>

}

// -------------------------------------------------
// Keyworks : includes operators that are words and should be
// before general things like IDENTIFIER which swallow almost
// anything

TOKEN : { <KW_A: "a" > }

TOKEN [IGNORE_CASE] :
{
// Prologue
   < BASE: "base" >
| < PREFIX: "prefix" >

// Result forms
| < SELECT: "select" >
| < DISTINCT: "distinct" >
| < REDUCED: "reduced" >
| < DESCRIBE: "describe" >
| < CONSTRUCT: "construct" >
| < ASK: "ask" >

| < LIMIT: "limit" >
| < OFFSET: "offset" >
| < ORDER: "order" >
| < BY: "by" >
| < GROUP: "group">



| < ASC: "asc" >
| < DESC: "desc" >

// Aggregation Functions
| < AVG: "avg" >
| < MAX: "max" >
| < MIN: "min" >
| < SUM: "sum" >
| < COUNT: "count" >

// Dataset
| < NAMED: "named" >
| < FROM: "from" >
| < STREAM: "stream" >

// Window
| < WINDOW: "window" >
| < RANGE: "range" >
| < SLIDE: "slide" >
| < ADVANCE: "advance" >
| < FIXED: "fixed" >
| < TRIPLES: "triples" > 
| < PWINDOW: "pwindow" >
| < START: "start" >
| < END: "end" >
| < REGISTER: "register" >
| < TO: "to" >
| < NOW: "now" >
| < AS: "as" >
| < TIMESTAMP: "timestamp" >

// Timeunit
| < MS: "MS" >
| < S: "S" >
| < SECOND: "second" >
| < MINUTE: "minute" >
| < HOUR: "hour" >
| < DAY: "day" >
| < WEEK: "week" >
| < MONTH: "month" >
| < YEAR: "year" >

// Graph pattern operators 
| < WHERE: "where" >
| < AND: "and" >
| < GRAPH: "graph" >
| < OPTIONAL: "optional" >
| < UNION: "union" >






| < FILTER: "filter" >

// Expression operators
| < BOUND: "bound" >
| < STR: "str" >
// |  < URI:         "uri" >
| < DTYPE: "datatype" >
| < LANG: "lang" >
| < LANGMATCHES: "langmatches" >
//|  < IS_IRI:      ("isIRI"|"isURI") >
| < IS_URI: "isURI" >
| < IS_IRI: "isIRI" >
| < IS_BLANK: "isBlank" >
| < IS_LITERAL: "isLiteral" >
| < REGEX: "regex" >
| < SAME_TERM: "sameTerm" >

| <TRUE: "true" >
| <FALSE: "false" >
}

// -------------------------------------------------

TOKEN :
{
  < #DIGITS: (["0"-"9"])+>
| < INTEGER: <DIGITS> >
| < DECIMAL: ( <DIGITS> "." (<DIGITS>)* | "." <DIGITS> ) >
| < DOUBLE: // Required exponent.
      (
        (["0"-"9"])+ "." (["0"-"9"])* <EXPONENT>
        | "." (["0"-"9"])+ (<EXPONENT>)
        | (["0"-"9"])+ <EXPONENT>
      )
      >

| < INTEGER_POSITIVE: <PLUS> <INTEGER> >
| < DECIMAL_POSITIVE: <PLUS> <DECIMAL> >
| < DOUBLE_POSITIVE: <PLUS> <DOUBLE> >

| < INTEGER_NEGATIVE: <MINUS> <INTEGER> >
| < DECIMAL_NEGATIVE: <MINUS> <DECIMAL> >
| < DOUBLE_NEGATIVE: <MINUS> <DOUBLE> >

| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < #QUOTE_3D: "\"\"\"">
| < #QUOTE_3S: "'''">
| <ECHAR: "\\" ( "t"|"b"|"n"|"r"|"f"|"\\"|"\""|"'") >
| < STRING_LITERAL1:
      // Single quoted string
      "'" ( (~["'","\\","\n","\r"]) | <ECHAR> )* "'" >
| < STRING_LITERAL2:
    // Double quoted string
      "\"" ( (~["\"","\\","\n","\r"]) | <ECHAR> )* "\"" >
| < STRING_LITERAL_LONG1:
     <QUOTE_3S>
      ( ("'" | "''")? (~["'","\\"] | <ECHAR> ))*
     <QUOTE_3S> >

| < STRING_LITERAL_LONG2:
     <QUOTE_3D>
      ( ("\"" | "\"\"")? (~["\"","\\"] | <ECHAR> ))*
     <QUOTE_3D> >
}

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >

| <NIL: <LPAREN> (<WS>|<SINGLE_LINE_COMMENT>)* <RPAREN> >

| < LBRACE: "{" >
| < RBRACE: "}" >

| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < ANON: <LBRACKET> (<WS>|<SINGLE_LINE_COMMENT>)* <RBRACKET> >

| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

// Operator

TOKEN :
{
  < EQ: "=" >
| < NE: "!=" >
| < GT: ">" >
| < LT: "<" >
| < LE: "<=" > // Maybe: | "=>" >
| < GE: ">=" > // Maybe: | "=<" >

| < BANG: "!" >
| < TILDE: "~" >
| < COLON: ":" >

| < SC_OR: "||" >
| < SC_AND: "&&" >

| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >

//| < AMP: "&" >
//| < REM: "%" >

| < DATATYPE: "^^">
| < AT: "@">
}

// See XML chars.txt for notes

TOKEN:
{
  // XML 1.1 NCNameStartChar without "_"
  <#PN_CHARS_BASE:
          ["A"-"Z"] | ["a"-"z"] |
          ["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"] | ["\u00F8"-"\u02FF"] |
          ["\u0370"-"\u037D"] | ["\u037F"-"\u1FFF"] |
          ["\u200C"-"\u200D"] | ["\u2070"-"\u218F"] | ["\u2C00"-"\u2FEF"] |
          ["\u3001"-"\uD7FF"] | ["\uF900"-"\uFFFD"]
          >
          // [#x10000-#xEFFFF]
|
  <#PN_CHARS_U: <PN_CHARS_BASE> | "_" >
|
// No DOT
  <#PN_CHARS: (<PN_CHARS_U> | "-" | ["0"-"9"] | "\u00B7" |
              ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] ) >
|
  // No leading "_", no trailing ".", can have dot inside prefix name.
  <#PN_PREFIX: <PN_CHARS_BASE> ((<PN_CHARS>|".")* <PN_CHARS>)? >
|
  // With a leading "_", no dot at end of local name.
  <#PN_LOCAL: (<PN_CHARS_U> | ["0"-"9"]) ((<PN_CHARS>|".")* <PN_CHARS>)? >
|
  // NCNAME without "-" and ".", allowing leading digits.
  <#VARNAME: ( <PN_CHARS_U> | ["0"-"9"] )
             ( <PN_CHARS_U> | ["0"-"9"] | "\u00B7" |
               ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] )* >
}

// Catch-all tokens.  Must be last.  
// Any non-whitespace.  Causes a parser exception, rather than a
// token manager error (with hidden line numbers).
// Only bad IRIs (e.g. spaces) now give unhelpful parse errors.
TOKEN:
{
  <#UNKNOWN: (~[" ","\t","\n","\r","\f" ])+ >
}

/*
 * (c) Copyright 2004, 2005, 2006, 2007 Hewlett-Packard Development Company, LP
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
# Local Variables:
# tab-width: 4
# indent-tabs-mode: nil
# comment-default-style: "//"
# End:
*/
