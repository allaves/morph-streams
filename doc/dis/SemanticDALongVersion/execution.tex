\section{Implementation and Execution: Walkthrough}
\label{execution}

The presented approach of providing ontology-based access to streaming data has been implemented as an extension to the \odemapster processor \cite{Barrasa_04}. 
This implementation generates \sneeql queries that can be executed by the streaming query processor.


Consider the motivating example where a sensor network generates two streams \texttt{WindFolkestone} and \texttt{WindHernebay} of wind sensor measurements.
The associated stored information about the sensors, \eg location and type, are stored in a relation \texttt{Sensors}.

\begin{lstlisting}[style=SNEEqlStyle,language=Haskell,label=list:schema,caption=Relational schema of the stream data source.]
WindFolkestone: (sensorId INT PK, 
	timestamp DATETIME PK, 
	speed FLOAT, 
	direction FLOAT)
WindHernebay: (sensorId INT PK, 
	timestamp DATETIME PK, 
	speed FLOAT, 
	direction FLOAT)
Sensors: (sensorId INT PK, 
	sensorName CHAR(45), 
	lat FLOAT, 
	long FLOAT)
\end{lstlisting}

The schemas are presented in Listing~\ref{list:schema}. Also consider the following ontological view:
\vspace{-10pt}
\small
\begin{align*}%[style=SNEEqlStyle,language=Haskell,frame=none]
SpeedObservation \sqsubseteq\ & Observation \\
WindSpeedObservation \sqsubseteq\ & SpeedObservation \\
WindDirectionObservation \sqsubseteq\ & Observation \\
SpeedObservation \sqsubseteq\ & \exists observationResult \\
SpeedObservation \sqsubseteq\ & \exists observationResultTime \\
Observation \sqsubseteq\ & \exists isProducedBy.Sensor \\
Sensor \sqsubseteq\ & \exists hasLatitude \\
Sensor \sqsubseteq\ & \exists hasLongitude \\
\end{align*}

\normalsize
We can define an \stwoo mapping that unifies the \texttt{WindFolkestone} and \texttt{WindHernebay} stream tuples into instances of a $WindSpeedObservation$ concept. 
Listing~\ref{list:s2o-wind-ex} is an extract of the \stwoo mapping document concerning the $WindSpeedObservation$.
The mapping extract defines how to construct the $WindSpeedObservation$ and $Sensor$ class instances from the streams \texttt{WindFolkestone} and \texttt{WindHernebay} and the \texttt{Sensors} table: 
\begin{align*}
 \Psi_{WindSpeedObservation}\leadsto 
		&\Phi_{
				\begin{subarray}{l} 
				\mathtt{WindFolkestone}\\
				\mathtt{WindHernebay} 
				\end{subarray}}\\ 
%
 \Psi_{Sensor}\leadsto 
		&\Phi_{\mathtt{Sensors}}
\end{align*} 
In the case of the $WindSpeedObservation$ the function $f_{WindSpeedObservation}^{Id}$ produces the \uri's of the instances by concatenating the \texttt{sensorId} and \texttt{timestamp} attributes.
Now we can pose a query over the ontology using \sparqlstr, for example to obtain the wind speed measurements taken in the last 10 minutes (See the query in Listing~\ref{list:query-example}).

\begin{lstlisting}[style=R2OStyle,language=R2O,frame=none,float,label=list:s2o-wind-ex,caption=\stwoo mapping from the data streams \texttt{WindFolkestone} and \texttt{WindHernebay} to the ontology concepts $WindSpeedObservation$.]
conceptmap-def WindSpeedObservation
	virtualStream <http://semsorgrid4env.eu/SensorReadings.srdf>
	uri-as
			concat('http://semsorgrid4env.eu/WindSpeedObservation_', SensorWind.sensorId, 	SensorWind.timestamp)
		union 
			alias SensorWind
			WindFolkestone
			WindHernebay
	described-by
		attributemap-def observationResult
			operation constant
				has-column SensorWind.speed
		attributemap-def observationResultTime
			operation constant
				has-column SensorWind.timestamp
		dbrelationmap-def isProducedBy
			toConcept Sensor
			joins-via
				condition equals
					has-column Sensors.sensorId
					has-column SensorWind.sensorId

conceptmap-def Sensor
	uri-as
		concat('http://semsorgrid4env.eu/Sensor_',Sensors.sensorId)
	described-by
		attributemap-def hasLatitude
			operation constant
				has-column Sensors.lat
		attributemap-def hasLongitude
			operation constant
				has-column Sensors.lon
\end{lstlisting}


\begin{lstlisting}[style=SPARQLSTRStyle,language=SPARQLSTR,frame=none,float,label=
list:query-example,caption=\sparqlstr query which every minute returns the wind speed for the last ten minutes.]
PREFIX fire: <http://www.ssg4env.eu/fireObservation#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
SELECT RSTREAM ?speed ?time ?lat ?lon
FROM STREAM <www.ssg4env.eu/SensorReadings.srdf> [FROM NOW - 10 MINUTES TO NOW STEP 1 MINUTE]
WHERE {
	?WindSpeed a fire:WindSpeedObservation;
		fire:observationResult ?speed;
		fire:observationResultTime ?time;
		fire:isProducedBy ?Sensor.
  	?Sensor a fire:Sensor; 
		fire:hasLatitute ?lat;
		fire:hasLonitude ?lon.
}
\end{lstlisting}


A class query atom $WindSpeedObservation(x)$ and the $observationResultTime(x,t)$ and  $observationResult(x,z)$ datatype property atoms can be extracted from the \sparqlstr query. \\
The window specification:
\begin{align*}
 [t_s=\textsf{\small{NOW}}-10,t_e=\textsf{\small{NOW}},\delta=1]
\end{align*}
 is also obtained\footnote{For the simplicity of presentation, we assume that the system rewrites all time specifications to minutes.
The implemented system uses milliseconds as the common time unit.}.
The \stwoo mapping defines that $WindSpeedObservation$ instances are generated based on the \texttt{sensorId} and \texttt{timestamp} attributes of the \texttt{WindFolkestone} and \texttt{WindHernebay} streams, using a concatenation function to generate each instance \uri.
% Hence the processor will evaluate
%\begin{align*}
%\lambda(\Phi_{\mathtt{windsamples}}(x_{\mathtt{sensorid}},x_{\mathtt{ts}}))[now-10,now,1]) %= \\ \pi_{\mathtt{sensorid,ts}}(\omega_{now-10,now,1}\mathtt{windsamples})
%\end{align*}
Similarly the \stwoo mapping defines that $observationResult$ properties are generated from the values of the \texttt{speed} attribute of the streams. \\
The processor will evaluate this as:
%\begin{figure*}
\begin{align*}
\lambda ( &\Phi_{ 
			\begin{subarray}{l}
			\mathtt{WindFolkestone}\\
			\mathtt{WindHernebay}
			\end{subarray}}
\left(
\begin{subarray}{l}
x_{\mathtt{sensorId}}\\x_{\mathtt{timestamp}}\\z_{\mathtt{speed}}
\end{subarray}
\right) {\scriptstyle [now-10,now,1]} ) =  \\ 
&\pi_{
\begin{subarray}{l}
\mathtt{sensorId}\\
\mathtt{timestamp}\\
\mathtt{speed}
\end{subarray}}
\left( \cup \left( 
	\begin{subarray}{l}
		\omega_{now-10,now,1}( \mathtt{WindFolkestone}) \\
		\omega_{now-10,now,1}(\mathtt{WindHernebay})
	\end{subarray}
\right) \right)
\end{align*}
%\end{figure*}
Similarly the evaluator will compute the $Sensor$ instances needed for the join that is produced in order to generate the $isProducedBy$ object property.
%In this case no joins and other selection conditions are needed, and only one stream has to be queried to produce the results. 
The query generated in the \sneeql language is shown in Listing~\ref{list:query-ex-sneeql}\footnote {Although the current available implementation of the SNEE processor lacks the \texttt{concat} operator, we include the sample query in its complete form here.}. The relational answer stream that results from evaluating the query in Listing~\ref{list:query-ex-sneeql} are transformed by the \textit{Data Transformation} module depicted in Figure~\ref{fig:SemanticIntegrator} according to the \stwoo mappings.
This results in a stream of tagged triples which are instances of the class $WindSpeedObservation$. According to the select statement of the \sparqlstr query, the result in this case will be a set of bound variables.

\begin{lstlisting}[style=SNEEqlStyle,language=SNEEql,frame=none,float,label=list:query-ex-sneeql,caption=The \sneeql query that is generated for the input query in Listing~\ref{list:query-example}.]
SELECT RSTREAM concat('http://ssg4env.eu#WindSpeedObservation_',
	WindSensor.sensorId,WindSensor.timestamp) AS id, 
	WindSensor.speed AS speed, Sensors.lat, Sensors.lon
FROM (
	SELECT sensorId, timestamp 
	FROM WindFolkestone [FROM NOW - 10 MINUTES TO NOW SLIDE 1 MINUTE] 
	UNION 
	SELECT sensorId, timestamp 
	FROM WindFolkestone [FROM NOW - 10 MINUTES TO NOW SLIDE 1 MINUTE] 
) AS WindSensor, Sensors 
WHERE WindSensor.sensorId = Sensors.sensorId; 
\end{lstlisting}





%Show transformation example, mention implementation in infancy.
%We need to code at this point and show minimal results.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rere"
%%% End: 
