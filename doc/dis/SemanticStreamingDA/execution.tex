\section{Implementation and Walkthrough}
\label{execution}

The presented approach of providing ontology-based access to streaming data has been implemented as an extension to the
ODEMapster processor \cite{Barrasa_04}. This implementation generates queries that can be executed by the SNEE
in-network or out-of-network streaming query processor, whose SNEEql query language is presented in
\cite{Brenninkmeijer_08}.

%\subsection{SNEEql language semantics}
%\label{sneeqlsemantics}

%We chose SNEEql as a target language because of it provides greater expressiveness in queries, including streams and relations, time and tuple windows, blocking and non-blocking operators, and pull and pushed based streams [Brenn, Galp], compared to other alternatives.
%The operational semantics of the SNEEql query language are detailed in [SNEEql] using an approach that consists on translating the logical algebraic operators into the Haskell functional programming language.
%The main data types are first defined( all complete definitions are available in [Brennik]):

%\begin{lstlisting}[style=HaskellSNEE,language=Haskell,frame=none]
%data Data
% = Tuple ([Attribute],[RawData])
% | TaggedTuple Tick Tuple
% | IndexedTuple Index Tick Tuple
% | BagOf [Tuple]
% | StreamOf [Data]
% | Window Tick BagOfTuples
%\end{lstlisting}

%As we can see we have streams of data defined as lists of \texttt{Data} elements, which can in turn be of type \texttt{TaggedTuple} or even \texttt{Window}. As Haskell is a lazy evaluation language, we can use lists for representing unbounded streams. As it can be seen windows are composed on a \texttt{Tick} and a bag of \texttt{Tuple}. Notice that a relation can be seen as a list of \texttt{Tuple}.
%Creating a window in SNEEql involves two steps, first determine when to create the window taking into account the slide parameter. Then the set of tuples to be included in the window must be determined using the time range of the window.
%Time-based window creation is performed by the \texttt{createTimeWindow} function that takes as parameters the time range \texttt{WindowScopeDef}, the slide, a tick representing the current timestamp (\texttt{NOW}) and a list of tagged tuples. A \texttt{Window} tagged with \texttt{NOW} tick is created, taking all tuples tagged before or at most at the current tick:

%\begin{lstlisting}[style=HaskellSNEE,language=Haskell,frame=none]
%createTimeWindow :: WindowScopeDef -> Tick -> Tick -> [IndexedTuple] -> [Window]
%\end{lstlisting}

%In order to transform streams of windows to streams of tagged tuples, the %\texttt{doRStream} function is defined:

%\begin{lstlisting}[style=HaskellSNEE,language=Haskell,frame=none]
%doRStream :: StreamOfWindows -> StreamOfTaggedTuples
%\end{lstlisting}

%Projection, selection, cross product and other operators are also defined in this way using operational semantics, more complete definitions can be found in [SNEEql, Brenn].

%\subsection{Execution walkthrough}

Consider the following example, a stream \texttt{windsamples} of wind sensor measurements  and a table \texttt{sensors}:
\begin{lstlisting}[style=HaskellSNEE,language=Haskell,frame=none]
windsamples: (sensorid INT PK,ts DATETIME PK,speed FLOAT,direction FLOAT)
sensors: (sensorid INT PK,sensorname CHAR(45))
\end{lstlisting}
And consider the following ontological view:
\begin{align*}%[style=HaskellSNEE,language=Haskell,frame=none]
SpeedMeasurement \sqsubseteq\ & Measurement \\
WindSpeedMeasurement \sqsubseteq\ & SpeedMeasurement \\
WindDirectionMeasurement \sqsubseteq\ & Measurement \\
SpeedMeasurement \sqsubseteq\ & \exists hasSpeed \\
Measurement \sqsubseteq\ & \exists isProducedBy.Sensor \\
Sensor \sqsubseteq\ & \exists hasName
\end{align*}
%
Then we can define an \stwoo\ mapping that splits the \texttt{windsamples} stream tuples into instances of two different concepts $WindSpeedMeasurement$ and \textit{WindDirectionMeasurement}. Here is an extract of the \stwoo\ mapping concerning the $WindSpeedMeasurement$.

\lstdefinestyle{R2O}{basicstyle=\sffamily\scriptsize,
                        %keywordstyle=\lstuppercase,
                        emphstyle=\itshape,
                        showstringspaces=false,
                        }
\begin{lstlisting}[style=R2OStyle,language=R2O,frame=none]
conceptmap-def WindSpeedMeasurement
 virtualStream <http://ssg4env.eu/SensorReadings.srdf>
 uri-as
   concat('ssg4env:WindSM_',windsamples.sensorid,windsamples.ts)
 described-by
  attributemap-def hasSpeed
   operation constant
     has-column windsamples.speed
  dbrelationmap-def isProducedBy
   toConcept Sensor
   joins-via
     condition equals
      has-column sensors.sensorid
      has-column windsamples.sensorid

conceptmap-def Sensor
 uri-as
   concat('ssg4env:Sensor_',sensors.sensorid)
 described-by
  attributemap-def hasSensorid
   operation constant
     has-column sensors.sensorid
\end{lstlisting}
%
The mapping extract here defines how to construct the $WindSpeedMeasurement$ ($WindSM$) and $Sensor$ class instances from the \texttt{windsamples} stream and the \texttt{sensors} table: $\Psi_{WindSM}\leadsto \Phi_{\mathtt{windsamples}}$ and $\Psi_{Sensor}\leadsto \Phi_{\mathtt{sensors}}$. In the case of the $WindSpeedMeasurement$ the function $f_{WindSM}^{Id}$ produces the URI's of the instances by concatenating the \texttt{sensorid} and \texttt{ts} attributes.
%explain the rest of the expression
Now we can pose a query over the ontology using \sparqlstr\, for example to obtain the wind speed measurements taken in the last 10 minutes.
\begin{lstlisting}[style=SPARQLSTRStyle,language=SPARQLSTR,frame=none]
PREFIX fire: <http://www.ssg4env.eu#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
SELECT ?speed
FROM STREAM <www.ssg4env.eu/SensorReadings.srdf> [RANGE 10 MINUTE STEP 1 MINUTE]
WHERE {
?WindSpeed a fire:WindSpeedMeasurement;
fire:hasSpeed ?speed;
}
\end{lstlisting}

A class query atom $WindSpeedMeasurement(x)$ and a datatype property atom $hasSpeed(x,z)$ can be extracted from the \sparqlstr\ query. The window specification $[t_i=now-10,t_f=now,\delta=1,unit=minutes]$ is also obtained. As it is defined in the \stwoo\ mapping the $WindSpeedMeasurment$ instances are generated based on the \texttt{sensorid} and \texttt{ts} attributes of the \texttt{windsamples} stream, using a concatenation function to generate each instance URI.
% Hence the processor will evaluate
%\begin{align*}
%\lambda(\Phi_{\mathtt{windsamples}}(x_{\mathtt{sensorid}},x_{\mathtt{ts}}))[now-10,now,1]) %= \\ \pi_{\mathtt{sensorid,ts}}(\omega_{now-10,now,1}\mathtt{windsamples})
%\end{align*}
Similarly the \stwoo\ mapping defines that $hasSpeed$ properties are generated from the values of the speed attribute of the \texttt{windsamples} stream. The processor will evaluate this as:
\begin{align*}
\lambda(\Phi_{\mathtt{windsamples}}(x_{\mathtt{sensorid}},x_{\mathtt{ts}},z_{\mathtt{speed}})[now-10,now,1]) = \\ \pi_{\mathtt{sensorid,ts,speed}}(\omega_{now-10,now,1} \mathtt{windsamples})
\end{align*}
In this case no joins and other selection conditions are needed, and only one stream has to be queried to produce the results. The query generated in the SNEEql language is the following\footnote {Although the current available implementation of the SNEE processor lacks the \texttt{concat} operator, we include the sample query in its complete form here.}:

\begin{lstlisting}[style=HaskellSNEE,language=SQL,frame=none]
SELECT RSTREAM concat('http://ssg4env.eu#WindSM',windsensor.id,windsensor.ts )
as  id ,( windsamples.speed ) as  speed
FROM windsamples[FROM NOW - 10 MINUTE]
\end{lstlisting}
%
The results will be transformed into tagged triples, instances of the class \\ $WindSpeedMeasurement$.



%Show transformation example, mention implementation in infancy.
%We need to code at this point and show minimal results.
