
\section{Preliminaries}
\label{sec:background}

This section describes the existing work upon which our approach is based, \ie ontology-based data access and querying through mappings, and data access fro streaming data.
A full discussion of related work can be found in Section~\ref{sec:related-work}.


\subsection{Ontology-based Access to Stored Relational Data}
\label{sec:ontol-based-access-stored}

The goal of ontology-based data access is to generate semantic web content from existing relational data sources available on the web \cite{Sahoo_09}.
The objective of systems following this approach is to allow users to construct queries over an ontology (\eg using a query language as \sparql), which are then rewritten into a set of queries expressed in the query language of the data source (typically \sql), according to the specified mappings.
The query results are then converted back from the relational format into \rdf, which is returned to the user.
\odemapster is one such system which uses the \rtwoo (Relational-to-Ontology) language to express the mappings between the relational data source and the ontology \cite{Barrasa_04}.

The mapping definition language \rtwoo defines relationships between a set of ontologies and relational schemas \cite{Barrasa_04}.
The resulting mappings are saved as \xml which enables them to be independent of any specific DBMS or ontology language.

\rtwoo\ specifically considers classes, object and datatype properties in an ontology. They are described in terms of selections and transformations over database relations following a Global-as-View (\gav) approach \cite{Lenzerini_02}, and can be created either manually or with the help of a mapping tool.
\rtwoo\ covers a wide set of mapping cases common in relational to ontology situations. \rtwoo\ is designed to cope with the following mapping cases:
\begin{itemize}
\item A database table maps to one class in the ontology. Then the table columns map to attributes or relations of the concept. For each row in the table a corresponding instance in the ontology will be generated, with its attribute values filled with the columns data.
\item A single database table is mapped to more than one class in the ontology, and for each row a single instance of each class is generated. %In this case some columns will be mapped to a concept attributes while other columns will be mapped to other concept attributes.
\item A single database table is mapped to more than one class in the ontology, and multiple instances can be generated for each class. It is a more general case than the previous one; multiple instances of the same ontology concept can be generated from a single database record.
\end{itemize}



Mapping relations to ontologies often requires performing operations on the relational sources.
Several cases are handled by \rtwoo and detailed below.
\begin{description}
\item[Direct Mapping.] A single relation maps to an ontology class and the attributes of the relation are used to fill the property values of the ontology instances. Each row in the relation will generate a class instance in the ontology.
\item[Join/Union.] A single relation does not correspond alone to a class, but it has to be combined with other relations. The result of the join or union of the relations will generate the corresponding ontology instances.
\item[Projection.] Not all the attributes of a relation are always required for the mapping. The unnecessary attributes can simply be ignored. In order to do so, a projection on the needed attributes can be performed.
\item[Selection.] Not all rows of a relation correspond to instances of the mapped ontology class. A subset of the rows must be extracted. To do so, selection conditions can be applied to choose the desired subset for the mapping.
\end{description}
It is possible to combine joins, unions, projections and selections for more complex mapping definitions.
\rtwoo also enables the application of functions, \eg concatenation, sub-string, or arithmetic functions, to transform the relational data into the appropriate form for the ontology.



\subsection{Querying Relational Streams}
\label{sec:query-relat-streams}

A relational data stream is an append only, potentially infinite, sequence of timestamped tuples \cite{Golab2003Issues-in-data-}, examples of which include stock market tickers, heart rate monitors, and sensor networks deployed to monitor the environment.
Data streams can be classified into two categories:
\begin{description}
\item[Event-streams.] A tuple is generated each time an event occurs, \eg the sale of shares, and can have variable, potentially very high, data rates.
\item[Acquisitional-streams.] A tuple is measured at a predefined regular interval, \eg the readings made by a sensor network.
\end{description}
Users are typically interested in being informed continuously about the most recent stream values, with older tuples being less relevant.
Classical database query processing is not adequate since data must first be stored and then queried with one-off evaluation.
Hence, query languages \cite{Brenninkmeijer_08,Arasu_2006} and data stream management systems (DSMS) \cite{Arasu_06a,Abadi_2005,Galpin_09,Madden_05} have been developed to process continuous long-lived queries over data streams as tuples arrive.

One existing approach is \sneeql, which has a well defined, unified semantics for declarative expressions of data needs over event-streams, acquisitional-streams, and stored data \cite{Brenninkmeijer_08}.
\sneeql can be viewed as extending \sql for processing data streams.
The main additional constructs of relational streaming query languages are explained below. and we present them using the \sneeql syntax. 
\begin{description}
\item[Window.] A window over a data stream transforms the infinite sequence of tuples into a bounded bag of tuples over which traditional relational operators can be applied. A window is specified as: 
\begin{align*}
\textsf{\small{FROM}}\ {start}\ \textsf{\small{TO}}\ {end}\ [\textsf{\small{SLIDE}}\ {int}\ {unit}]
\end{align*}
Where ${start}$ and ${end}$ are of the form `$\textsf{\small{NOW}} - {literal}$' and define the range of the window with respect to the evaluation time. The optional \textsf{\small{SLIDE}} parameter specifies how often windows are evaluated.

\item[Window-to-Stream.] Window-to-stream operators are used to convert a stream of windows into a stream of tuples. \sneeql supports three such operators: \textsf{\small{RSTREAM}} for all tuples appearing in the window, \textsf{\small{ISTREAM}} for tuples that have been added since the last window evaluation, and \textsf{\small{DSTREAM}} for tuples that have been deleted since the last window evaluation.
\end{description}
%Queries expressed in the \sneeql language are optimized for evaluation within a sensor network over acquisitional-streams by the \snee compiler \cite{Galpin_09}. \snee has recently been extended to enable query evaluation over event-streams either within the sensor network (in-network query processing) or on computational hardware outside of the sensor network.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rere"
%%% End: 
